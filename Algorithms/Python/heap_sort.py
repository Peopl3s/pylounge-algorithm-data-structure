'''
Пирамидальная сортировка (Heap Sort)

Суть сортировки
1. Постройте max-heap (непозрастающая пирамида) из входных данных.
2. Самый большой элемент хранится в корне (пирамиды) кучи. 
Замените его на последний элемент кучи, а затем уменьшите ее размер на 1. 
3. Преобразовать полученное дерево в max-heap с новым корнем.
4. Повторять вышеуказанные шаги, пока размер кучи больше 1.

Сложность сортировки по времени:
Худшая O(n * log n)
Средняя O(n * log n)
Лучшая O(n * log n)

Достоинства:
-Имеет доказанную оценку худшего случая O(n * log n).
-Сортирует на месте, то есть требует всего O(1) дополнительной памяти.

Недостатки:
-Неустойчив — для обеспечения устойчивости нужно расширять ключ.
-На почти отсортированных массивах работает столь же долго, как и на хаотических данных.
-На одном шаге выборку приходится делать хаотично по всей длине массива — поэтому алгоритм плохо сочетается с кэшированием и подкачкой памяти.
-Методу требуется «мгновенный» прямой доступ; не работает на связанных списках и других структурах памяти последовательного доступа.
-Не распараллеливается.

Из-за сложности алгоритма выигрыш получается только на больших n. На небольших n (до нескольких тысяч) быстрее сортировка Шелла.
'''

def heap_sort(arr):
  build_max_heap(arr)
  for i in range(len(arr) - 1, 0, -1):
    arr[0], arr[i] = arr[i], arr[0]
    max_heapify(arr, index=0, size=i)
  return arr

def parent(index):
  return index // 2

def left(index):
  return 2 * index

def right(index):
  return 2 * index + 1 

def build_max_heap(arr):
  '''Строит невозрастающую пирамиду'''
  length = len(arr)
  start = parent(length - 1)
  while start >= 0:
    max_heapify(arr, index=start, size=length)
    start -= 1

def max_heapify(arr, index, size):
  '''Перестраивает пирамиду, чтобы поддерживались свойства 
  невозрастающей пирамиды (значение родительского узла больше дочернего)'''
  l = left(index)
  r = right(index)
  if l < size and arr[l] > arr[index]:
    largest = l
  else:
    largest = index
  if r < size and arr[r] > arr[largest]:
    largest = r
  if largest != index:
    arr[largest], arr[index] = arr[index], arr[largest]
    max_heapify(arr, largest, size - 1)

arr = [1, 99, 6, -4, 2, 6, 9]
print(heap_sort(arr))