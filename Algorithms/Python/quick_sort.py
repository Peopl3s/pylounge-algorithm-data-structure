'''
Быстрая сортировка (Quick Sort)

Суть сортировки:
1. Выбрать опорный (pivot) элемент из массива. 
Обычно опорным элементом является средний или случайный элемент.
2. Разделить массив на два подмассива: элементы меньше опорного и 
элементы больше опорного.
3. Рекурсивно применить сортировку к двум подмассивам.

Сложность сортировки по времени:
Худшая O(n^2)
Средняя O(n * log2n)
Лучшая O(n * 2log 2n)

Достоинства:
1.Один из самых быстродействующих (на практике) из алгоритмов 
внутренней сортировки общего назначения.
2.Алгоритм очень короткий: запомнив основные моменты, 
его легко написать «из головы».
3.Требует лишь  O(1) дополнительной памяти для своей работы.
4.Хорошо сочетается с механизмами кэширования и виртуальной памяти.
5.Допускает естественное распараллеливание.
6.Допускает эффективную модификацию (разбиение Хоара, Ломуто,
выбор опорного элемента).
7.Работает на связных списках и других структурах с последовательным 
доступом, допускающих эффективный проход как от начала к концу, 
так и от конца к началу.

Недостатки:
1. Сильно деградирует по скорости в худшем или близком к нему случае.
(будет работать медленно, если опорный элемент равен 
наименьшему или наибольшему элементам списка(.
2.Неустойчив.
'''

def quick_sort(arr, start, finish):
  if finish - start > 1:
    p = partition(arr, start, finish)
    quick_sort(arr, start, p)
    quick_sort(arr, p + 1, finish)
  return arr

def partition(arr, start, finish):
  pivot = arr[start] # пусть опорный 1-й элемент
  i = start + 1
  j = finish - 1

  while True:
    while (i <= j and arr[i] <= pivot):
      i += 1
    while (i <= j and arr[j] >= pivot):
      j = j - 1

    if i <= j:
      arr[i], arr[j] = arr[j], arr[i]
    else:
      arr[start], arr[j] = arr[j], arr[start]
      return j

l = [1, 87, 2, 0, 354]
print(quick_sort(l, 0, len(l)))